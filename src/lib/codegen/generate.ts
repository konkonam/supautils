import type { Config, Output } from '@/types'

import { defaultConfig } from '@/lib/config'
import { makeContext, transformColumn } from '@/lib/codegen'
import { PostgresMetaWithChecks } from '@/lib/db'
import { appHooks } from '@/lib/hooks'

import { dirname, join } from 'node:path'
import { mkdir, rm, writeFile } from 'node:fs/promises'
import { existsSync } from 'node:fs'
import defu from 'defu'

export async function generateOutputs(config: Partial<Config> = defaultConfig) {
    const mergedConfig = defu(config, defaultConfig)

    const meta = new PostgresMetaWithChecks({ connectionString: mergedConfig.url })

    const context = await makeContext(meta, mergedConfig)

    const outputs: Output[] = []

    for (const configuredOutput of context.config.outputs) {
        if (!configuredOutput.path) {
            throw new Error('Output path is required')
        }

        let content = '// This file is generated by supautils\n\n'

        if (configuredOutput.imports) {
            content += configuredOutput.imports.join('\n') + '\n'
        }

        for (const table of context.tables) {
            const columns = table.columns.map((column) => {
                return transformColumn({
                    column: {
                        ...column,
                        name: configuredOutput.transformers['transform:columnname'](column.name),
                    },
                    transformers: configuredOutput.transformers,
                })
            }).join(',\n')

            const result = configuredOutput.transformers['transform:table']({
                table: {
                    ...table,
                    name: configuredOutput.transformers['transform:tablename'](table.name),
                },
                columns,
            })

            content += result + '\n\n'
        }

        outputs.push({
            path: join(process.cwd(), context.config.outputDir, configuredOutput.path),
            clear: configuredOutput.clear,
            content,
        })
    }

    await context.meta.end()

    return outputs
}

export async function writeOutputs(outputs: Output[]) {
    for (const output of outputs) {
        await appHooks.callHook('write:before', output)

        if (existsSync(output.path) && output.clear) {
            await rm(output.path)
        }

        mkdir(dirname(output.path), { recursive: true })
        writeFile(output.path, output.content, 'utf8')

        await appHooks.callHook('write:after', output)
    }
}
