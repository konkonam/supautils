import type { Config, Output } from '@/types'

import { defaultConfig } from '@/lib/config'
import { makeContext, transformColumn } from '@/lib/codegen'
import { PostgresMetaWithChecks } from '@/lib/db'
import { appHooks } from '@/lib/hooks'

import { dirname, join } from 'node:path'
import { mkdir, rm, writeFile } from 'node:fs/promises'
import { existsSync } from 'node:fs'
import defu from 'defu'

/**
 * Generates outputs based on the provided config
 */
export async function generateOutputs(config: Partial<Config> = defaultConfig) {
    const mergedConfig = defu(config, defaultConfig)
    const meta = new PostgresMetaWithChecks({ connectionString: mergedConfig.url })
    const context = await makeContext(meta, mergedConfig)
    const outputs: Output[] = []

    // Iterate over configured outputs and generate content for each
    for (const configuredOutput of context.config.outputs) {
        let content = '// This file is generated by supautils\n\n'

        // Add imports if configured in output
        if (configuredOutput.imports) {
            content += configuredOutput.imports.join('\n') + '\n'
        }

        for (const table of context.tables) {
            // Iterate over columns and transform them to one big string
            const columns = table.columns.map((column) => {
                column.name = configuredOutput.transformers['transform:columnname'](column.name)

                return transformColumn({
                    column,
                    transformers: configuredOutput.transformers,
                })
            }).join(',\n')

            table.name = configuredOutput.transformers['transform:tablename'](table.name)

            // Transform table to string using configured transformers
            const result = configuredOutput.transformers['transform:table']({
                table,
                columns,
            })

            content += result + '\n\n'
        }

        outputs.push({
            path: join(process.cwd(), context.config.outputDir, configuredOutput.path),
            clear: configuredOutput.clear,
            content,
        })
    }

    // Close the connection gracefully
    await context.meta.end()

    return outputs
}

/**
 * Utility to write outputs to the file system
 */
export async function writeOutputs(outputs: Output[]) {
    for (const output of outputs) {
        await appHooks.callHook('write:before', output)

        // Clear the file if it exists and clear is true
        if (existsSync(output.path) && output.clear) {
            await rm(output.path)
        }

        mkdir(dirname(output.path), { recursive: true })
        writeFile(output.path, output.content, 'utf8')

        await appHooks.callHook('write:after', output)
    }
}
